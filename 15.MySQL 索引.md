# MySQL 索引
## 什么是索引？
```
(root@localhost)[dbt3]> show create table orders\G
*************************** 1. row ***************************
       Table: orders
Create Table: CREATE TABLE `orders` (
  `o_orderkey` int(11) NOT NULL,
  `o_custkey` int(11) DEFAULT NULL,
  `o_orderstatus` char(1) DEFAULT NULL,
  `o_totalprice` double DEFAULT NULL,
  `o_orderDATE` date DEFAULT NULL,
  `o_orderpriority` char(15) DEFAULT NULL,
  `o_clerk` char(15) DEFAULT NULL,
  `o_shippriority` int(11) DEFAULT NULL,
  `o_comment` varchar(79) DEFAULT NULL,
  PRIMARY KEY (`o_orderkey`),------------主键索引，每张表只能有一个
  KEY `i_o_orderdate` (`o_orderDATE`),-----------
  KEY `i_o_custkey` (`o_custkey`),
  CONSTRAINT `orders_ibfk_1` FOREIGN KEY (`o_custkey`) REFERENCES `customer` (`c_custkey`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
1 row in set (0.00 sec)

1. 每个表只能有一个主键索引，但是可能有多个唯一索引
2. 索引会对索引字段进行排序
3. 查询速度非常快
4. 索引会增加维护成本


```
## B+Tree

1. The primary value of a B+ tree is in storing data for efficient retrieval in a block-oriented storage context—in particular, filesystems.
2. In contrast to a B-tree, “all records” are stored at the leaf level of the tree; only keys are stored in interior nodes.
3. B+ trees have very high fanout (typically on the order of 100 or more), which reduces the number of I/O operations required to find an element in the tree.


### 节点
1. root page 根页
2. non leaf page 非页节点
3. leaf page 叶子节点 （数据是逻辑排序的）
4. 叶子节点存储所有的数据，并且叶子之间是有序的。叶子节点中的记录也是有序的。这里面的有序都是逻辑有序 而不是物理上连续。
5. fanout 扇出 就是指针

B+ TREE 并不能直接找到一条记录，只能找到某条记录在哪个page。而这条记录在page的哪个位置，是需要page search二分法查找的。
### 二分法算法
```


```


```
//块大小 也是页面大小
(root@localhost)[test]> show variables like 'innodb_page_size%';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| innodb_page_size | 16384 |
+------------------+-------+
1 row in set (0.04 sec)

```
## 索引语法
### 添加索引
```
mysql> create table t (a int,b int);
Query OK, 0 rows affected (0.14 sec)

mysql> show create table t;
+-------+----------------------------------------------------------------------------------------------------------------+
| Table | Create Table                                                                                                   |
+-------+----------------------------------------------------------------------------------------------------------------+
| t     | CREATE TABLE `t` (
  `a` int(11) DEFAULT NULL,
  `b` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 |
+-------+----------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)

mysql> alter table t add index idx_a(a);
Query OK, 0 rows affected (0.05 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> alter table t add unique index idx_b(b);
Query OK, 0 rows affected (0.08 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> show create table t;
+-------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Table | Create Table                                                                                                                                                    |
+-------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| t     | CREATE TABLE `t` (
  `a` int(11) DEFAULT NULL,
  `b` int(11) DEFAULT NULL,
  UNIQUE KEY `idx_b` (`b`),
  KEY `idx_a` (`a`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 |
+-------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)
```
### 删除索引
```
mysql> alter table t drop index idx_a;
Query OK, 0 rows affected (0.10 sec)
Records: 0  Duplicates: 0  Warnings: 0


mysql> show create table t;
+-------+--------------------------------------------------------------------------------------------------------------------------------------------+
| Table | Create Table                                                                                                                               |
+-------+--------------------------------------------------------------------------------------------------------------------------------------------+
| t     | CREATE TABLE `t` (
  `a` int(11) DEFAULT NULL,
  `b` int(11) DEFAULT NULL,
  UNIQUE KEY `idx_b` (`b`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 |
+-------+--------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)
```

####  online ddl操作
针对数据量不大的表。进行online ddl完全是没问题的。但是，如果数据量大的话，就要考虑一些问题了。

```
online ddl的时候，会将在ddl期间产生的日志写入内存，而这个内存默认值为128M 如果数据量比较大，这个内存不够用的话，ddl将会报错不成功。
建议把这个值调整大一些。

mysql> show variables like 'innodb_online_alter_log_max_size';
+----------------------------------+-----------+
| Variable_name                    | Value     |
+----------------------------------+-----------+
| innodb_online_alter_log_max_size | 134217728 |
+----------------------------------+-----------+
1 row in set (0.01 sec)

mysql> select 134217728/1024/1024;
+---------------------+
| 134217728/1024/1024 |
+---------------------+
|        128.00000000 |
+---------------------+
1 row in set (0.01 sec)```


// innodb_online_alter_log_max_size 不支持session设置
mysql> set  innodb_online_alter_log_max_size = 512 * 1024 * 1024;
ERROR 1229 (HY000): Variable 'innodb_online_alter_log_max_size' is a GLOBAL variable and should be set with SET GLOBAL

mysql> set global innodb_online_alter_log_max_size = 512 * 1024 * 1024;
Query OK, 0 rows affected (0.00 sec)

mysql> show variables like 'innodb_online_alter_log_max_size';
+----------------------------------+-----------+
| Variable_name                    | Value     |
+----------------------------------+-----------+
| innodb_online_alter_log_max_size | 536870912 |
+----------------------------------+-----------+
1 row in set (0.01 sec)


vim /etc/my.cnf
innodb_online_alter_log_max_size = 512M

```

##### online ddl如果执行时间比较长，会造成主从延迟的问题
## Percona-Toolkit
### Mac安装Percona-Toolkit
```
//1.  下载
wget https://www.percona.com/downloads/percona-toolkit/3.0.5/source/tarball/percona-toolkit-3.0.5.tar.gz
//解压
tar zxvf percona-toolkit-3.0.5.tar.gz
cd /Users/ShaoGaoJie/Works/mysqldata/percona-toolkit-3.0.5
cd bin

//直接执行bin 下的命令，发现这么执行报错。那换个思路 直接安装试试
./pt-online-schema-change --alter "convert to character set utf8mb4" D=test,t=t --dry-run --host=127.0.0.1 --port=3307 -user=root
Cannot connect to MySQL: Cannot connect to MySQL because the Perl DBD::mysql module is not installed or not found.  Run 'perl -MDBD::mysql' to see the directories that Perl searches for DBD::mysql.  If DBD::mysql is not installed, try:
  Debian/Ubuntu  apt-get install libdbd-mysql-perl
  RHEL/CentOS    yum install perl-DBD-MySQL
  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql
  
// 安装的正确姿势
cd /Users/ShaoGaoJie/Works/mysqldata/percona-toolkit-3.0.5

➜  percona-toolkit-3.0.5 git:(pt-3.0.5-pre-release) perl ./Makefile.PL
Checking if your kit is complete...
Looks good
Warning: prerequisite DBD::mysql 3 not found.
Warning: NAME must be a package name
Generating a Unix-style Makefile
Writing Makefile for percona-toolkit
Writing MYMETA.yml and MYMETA.json

// make 
➜  percona-toolkit-3.0.5 git:(pt-3.0.5-pre-release) ✗ make
cp lib/CopyRowsInsertSelect.pm blib/lib/CopyRowsInsertSelect.pm
cp lib/ChangeHandler.pm blib/lib/ChangeHandler.pm
cp lib/bash/mysql_options.sh blib/lib/bash/mysql_options.sh
cp lib/Progress.pm blib/lib/Progress.pm
.
.
.
.
cp bin/pt-visual-explain blib/script/pt-visual-explain
"/usr/bin/perl" -MExtUtils::MY -e 'MY->fixin(shift)' -- blib/script/pt-visual-explain
Manifying 33 pod documents


// make install
➜  percona-toolkit-3.0.5 git:(pt-3.0.5-pre-release) ✗ make install
Manifying 33 pod documents
Installing /Users/ShaoGaoJie/perl5/lib/perl5/ChangeHandler.pm
Installing /Users/ShaoGaoJie/perl5/lib/perl5/CopyRowsInsertSelect.pm
Installing /Users/ShaoGaoJie/perl5/lib/perl5/VersionCheck.pm
.
.
.
.
Installing /Users/ShaoGaoJie/perl5/bin/pt-sift
Installing /Users/ShaoGaoJie/perl5/bin/pt-table-sync
Installing /Users/ShaoGaoJie/perl5/bin/pt-variable-advisor
Appending installation info to /Users/ShaoGaoJie/perl5/lib/perl5/darwin-thread-multi-2level/perllocal.pod
```
### pt-online-schema-change 使用以及原理分析
```
//重新执行pt-online-schema-change命令试试

// --dry-run 只是看看执行步骤 具体操作是不进行的。
➜  pt-online-schema-change --alter "convert to character set utf8mb4" D=test,t=t --dry-run --host=127.0.0.1 --port=3307 --user=root

 A software update is available:
   * The current version for Percona::Toolkit is 3.0.1

Operation, tries, wait:
  analyze_table, 10, 1
  copy_rows, 10, 0.25
  create_triggers, 10, 1
  drop_triggers, 10, 1
  swap_tables, 10, 1
  update_foreign_keys, 10, 1
Starting a dry run.  `test`.`t` will not be altered.  Specify --execute instead of --dry-run to alter the table.
Creating new table...
Created new table test._t_new OK.
Altering new table...
Altered `test`.`_t_new` OK.
Not creating triggers because this is a dry run.
Not copying rows because this is a dry run.
Not swapping tables because this is a dry run.
Not dropping old table because this is a dry run.
Not dropping triggers because this is a dry run.
2018-01-05T23:49:59 Dropping new table...
2018-01-05T23:49:59 Dropped new table OK.
Dry run complete.  `test`.`t` was not altered.
  

// --dry-run 真实处理convert to character set utf8mb4 ddl操作
➜  pt-online-schema-change --alter "convert to character set utf8mb4" D=test,t=t  --host=127.0.0.1 --port=3307 --user=root --execute
No slaves found.  See --recursion-method if host MacBook-Air-2.local has slaves.
Not checking slave lag because no slaves were found and --check-slave-lag was not specified.
Operation, tries, wait:
  analyze_table, 10, 1
  copy_rows, 10, 0.25
  create_triggers, 10, 1
  drop_triggers, 10, 1
  swap_tables, 10, 1
  update_foreign_keys, 10, 1
Altering `test`.`t`...
Creating new table...---------------------------------------创建新表
Created new table test._t_new OK.
Altering new table...---------------------------------------- 对新表进行ddl操作
Altered `test`.`_t_new` OK.
2018-01-05T23:56:56 Creating triggers...--------------------- 创建触发器
2018-01-05T23:56:56 Created triggers OK.
2018-01-05T23:56:56 Copying approximately 1 rows...----------- 拷贝数据
2018-01-05T23:56:56 Copied rows OK.
2018-01-05T23:56:56 Analyzing new table...
2018-01-05T23:56:56 Swapping tables...------------------------ 重命名原表和新表
2018-01-05T23:56:56 Swapped original and new tables OK.
2018-01-05T23:56:56 Dropping old table...---------------------删除老表
2018-01-05T23:56:56 Dropped old table `test`.`_t_old` OK.
2018-01-05T23:56:56 Dropping triggers...-----------------------删除触发器
2018-01-05T23:56:56 Dropped triggers OK.
Successfully altered `test`.`t`.--------------------------------过程结束
```

#### pt-online-schema-change原理分析
通过设置general_log来看执行pt-online-schema-change的时候，真实的过程是什么样儿的。

```
//具体执行过程详解
2018-01-05T16:10:20.043699Z	   18 Connect	root@localhost on test using SSL/TLS
2018-01-05T16:10:20.045067Z	   18 Query	SHOW VARIABLES LIKE 'innodb\_lock_wait_timeout'
2018-01-05T16:10:20.052367Z	   18 Query	SET SESSION innodb_lock_wait_timeout=1
2018-01-05T16:10:20.093491Z	   18 Query	SHOW VARIABLES LIKE 'lock\_wait_timeout'
2018-01-05T16:10:20.098282Z	   18 Query	SET SESSION lock_wait_timeout=60
2018-01-05T16:10:20.098804Z	   18 Query	SHOW VARIABLES LIKE 'wait\_timeout'
2018-01-05T16:10:20.105108Z	   18 Query	SET SESSION wait_timeout=10000
2018-01-05T16:10:20.105467Z	   18 Query	SELECT @@SQL_MODE
2018-01-05T16:10:20.105852Z	   18 Query	SET @@SQL_QUOTE_SHOW_CREATE = 1/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO,ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'*/
2018-01-05T16:10:20.106282Z	   18 Query	SELECT @@server_id /*!50038 , @@hostname*/
2018-01-05T16:10:20.146337Z	   19 Connect	root@localhost on test using SSL/TLS
2018-01-05T16:10:20.146975Z	   19 Query	SHOW VARIABLES LIKE 'innodb\_lock_wait_timeout'
2018-01-05T16:10:20.154392Z	   19 Query	SET SESSION innodb_lock_wait_timeout=1
2018-01-05T16:10:20.155158Z	   19 Query	SHOW VARIABLES LIKE 'lock\_wait_timeout'
2018-01-05T16:10:20.157647Z	   19 Query	SET SESSION lock_wait_timeout=60
2018-01-05T16:10:20.158019Z	   19 Query	SHOW VARIABLES LIKE 'wait\_timeout'
2018-01-05T16:10:20.159760Z	   19 Query	SET SESSION wait_timeout=10000
2018-01-05T16:10:20.160066Z	   19 Query	SELECT @@SQL_MODE
2018-01-05T16:10:20.160407Z	   19 Query	SET @@SQL_QUOTE_SHOW_CREATE = 1/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO,ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'*/
2018-01-05T16:10:20.160710Z	   19 Query	SELECT @@server_id /*!50038 , @@hostname*/
2018-01-05T16:10:20.161178Z	   18 Query	SHOW VARIABLES LIKE 'wsrep_on'
2018-01-05T16:10:20.163090Z	   18 Query	SHOW VARIABLES LIKE 'version%'
2018-01-05T16:10:20.165961Z	   18 Query	SHOW ENGINES
2018-01-05T16:10:20.166803Z	   18 Query	SHOW VARIABLES LIKE 'innodb_version'
2018-01-05T16:10:20.169262Z	   18 Query	SHOW VARIABLES LIKE 'innodb_stats_persistent'
2018-01-05T16:10:20.171112Z	   18 Query	SELECT @@SERVER_ID
2018-01-05T16:10:20.171542Z	   18 Query	SHOW SLAVE HOSTS
2018-01-05T16:10:20.172148Z	   18 Query	SHOW GLOBAL STATUS LIKE 'Threads_running'
2018-01-05T16:10:20.175237Z	   18 Query	SHOW GLOBAL STATUS LIKE 'Threads_running'
2018-01-05T16:10:20.178395Z	   18 Query	SELECT CONCAT(@@hostname, @@port)


2018-01-05T16:10:20.182423Z	   18 Query	SHOW TABLES FROM `test` LIKE 't'
// 查看test.t的触发器信息
2018-01-05T16:10:20.183671Z	   18 Query	SHOW TRIGGERS FROM `test` LIKE 't'
2018-01-05T16:10:20.184946Z	   18 Query	/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, @@SQL_MODE := '', @OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, @@SQL_QUOTE_SHOW_CREATE := 1 */

// 查看test.t 原表的建表语句
2018-01-05T16:10:20.185313Z	   18 Query	USE `test`
2018-01-05T16:10:20.185758Z	   18 Query	SHOW CREATE TABLE `test`.`t`
2018-01-05T16:10:20.238839Z	   18 Query	/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, @@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */

//  
2018-01-05T16:10:20.239864Z	   18 Query	EXPLAIN SELECT * FROM `test`.`t` WHERE 1=1
2018-01-05T16:10:20.241063Z	   18 Query	SELECT table_schema, table_name FROM information_schema.key_column_usage WHERE referenced_table_schema='test' AND referenced_table_name='t'
2018-01-05T16:10:20.271860Z	   18 Query	SHOW VARIABLES LIKE 'wsrep_on'
2018-01-05T16:10:20.273631Z	   18 Query	/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, @@SQL_MODE := '', @OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, @@SQL_QUOTE_SHOW_CREATE := 1 */
2018-01-05T16:10:20.273920Z	   18 Query	USE `test`
2018-01-05T16:10:20.274268Z	   18 Query	SHOW CREATE TABLE `test`.`t`
2018-01-05T16:10:20.274590Z	   18 Query	/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, @@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */

// 创建一个新表 `test`.`_t_new`
2018-01-05T16:10:20.274955Z	   18 Query	CREATE TABLE `test`.`_t_new` (
  `a` int(11) DEFAULT NULL,
  `b` int(11) DEFAULT NULL,
  UNIQUE KEY `idx_b` (`b`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4

// 对新表进行ddl语句的执行 由于是空表 那效率肯定是极高的。
2018-01-05T16:10:20.332576Z	   18 Query	ALTER TABLE `test`.`_t_new` convert to character set utf8mb4
2018-01-05T16:10:20.361083Z	   18 Query	/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, @@SQL_MODE := '', @OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, @@SQL_QUOTE_SHOW_CREATE := 1 */
2018-01-05T16:10:20.361444Z	   18 Query	USE `test`
2018-01-05T16:10:20.361789Z	   18 Query	SHOW CREATE TABLE `test`.`_t_new`
2018-01-05T16:10:20.362176Z	   18 Query	/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, @@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */

//创建delete的触发器
//!!!!!敲黑板!!!!!!  这里为什么是 DELETE IGNORE？？什么情况下 delete会出错呢？？
// 
2018-01-05T16:10:20.363163Z	   18 Query	CREATE TRIGGER `pt_osc_test_t_del` AFTER DELETE ON `test`.`t` FOR EACH ROW DELETE IGNORE FROM `test`.`_t_new` WHERE `test`.`_t_new`.`b` <=> OLD.`b`

//创建update的触发器
//!!!!!!敲黑板!!!!! 这里为什么是 REPLACE INTO？？
// 避免全量数据后执行，增量数据先执行。无论谁先执行，都会将最后的数据插进去。
2018-01-05T16:10:20.409402Z	   18 Query	CREATE TRIGGER `pt_osc_test_t_upd` AFTER UPDATE ON `test`.`t` FOR EACH ROW REPLACE INTO `test`.`_t_new` (`a`, `b`) VALUES (NEW.`a`, NEW.`b`)

//创建insert的触发器
//!!!!!!敲黑板!!!!! 这里为什么是 REPLACE INTO??
// 避免全量数据后执行，增量数据先执行。无论谁先执行，都会将最后的数据插进去。
2018-01-05T16:10:20.451092Z	   18 Query	CREATE TRIGGER `pt_osc_test_t_ins` AFTER INSERT ON `test`.`t` FOR EACH ROW REPLACE INTO `test`.`_t_new` (`a`, `b`) VALUES (NEW.`a`, NEW.`b`)


2018-01-05T16:10:20.511374Z	   18 Query	EXPLAIN SELECT * FROM `test`.`t` WHERE 1=1


2018-01-05T16:10:20.513816Z	   18 Query	EXPLAIN SELECT `a`, `b` FROM `test`.`t` LOCK IN SHARE MODE /*explain pt-online-schema-change 83142 copy table*/


//全量和增量的数据是无法控制谁先谁后的，顺序无法确定。
// 每张表必须要有一个主键 必须的！！！！

// 全量数据插入到新表 
//!!!!!!敲黑板!!!!!   为什么 INSERT LOW_PRIORITY IGNORE？为什么 LOCK IN SHARE MODE？
// 锁定读
// LOW_PRIORITY :插入这张表的时候，没有其他读的时候再插入，将优先级降低 
// IGNORE : 如果出错 则忽略。如果增量数据先执行了，又插入全量数据，则会出错。忽略这种错误。（顺序问题）
2018-01-05T16:10:20.514943Z	   18 Query	INSERT LOW_PRIORITY IGNORE INTO `test`.`_t_new` (`a`, `b`) SELECT `a`, `b` FROM `test`.`t` LOCK IN SHARE MODE /*pt-online-schema-change 83142 copy table*/
2018-01-05T16:10:20.515452Z	   18 Query	SHOW WARNINGS
2018-01-05T16:10:20.515953Z	   18 Query	SELECT @@SERVER_ID
2018-01-05T16:10:20.516273Z	   18 Query	SHOW SLAVE HOSTS
2018-01-05T16:10:20.516697Z	   18 Query	SHOW GLOBAL STATUS LIKE 'Threads_running'
2018-01-05T16:10:20.518316Z	   18 Query	ANALYZE TABLE `test`.`_t_new` /* pt-online-schema-change */

// 对老表进行重命名成 _old, _new表冲名称 t 投入使用
// Rename 原子操作。
2018-01-05T16:10:20.520194Z	   18 Query	RENAME TABLE `test`.`t` TO `test`.`_t_old`, `test`.`_t_new` TO `test`.`t`

// 删除老表
2018-01-05T16:10:20.612023Z	   18 Query	DROP TABLE IF EXISTS `test`.`_t_old`

// 删掉触发器
2018-01-05T16:10:20.617164Z	   18 Query	DROP TRIGGER IF EXISTS `test`.`pt_osc_test_t_del`
2018-01-05T16:10:20.617541Z	   18 Query	DROP TRIGGER IF EXISTS `test`.`pt_osc_test_t_upd`
2018-01-05T16:10:20.617855Z	   18 Query	DROP TRIGGER IF EXISTS `test`.`pt_osc_test_t_ins`
2018-01-05T16:10:20.618300Z	   18 Query	SHOW TABLES FROM `test` LIKE '\_t\_new'

//完成
2018-01-05T16:10:20.619132Z	   19 Quit
2018-01-05T16:10:20.622921Z	   18 Quit
```

##### 为什么pt osc主从没有特别大的延迟呢？
从机的sql执行是顺序的。
优点：延迟小，对数据库的影响比较小。
缺点：执行时间可能变长，因为要有个表数据的拷贝

#### gh-ost
https://github.com/github/gh-ost


## 索引组织表
1. 非叶节点 存储 键值和指针，指针占6个字节，键值根据数据类型而定。
2. 叶子节点 存储全部列的数据
3. 主键叶子节点存储所有的列，二级索引的叶子节点存储索引的值和主键。


### 根据上面的规则做个计算题
> 假设一个表的主键是bigint，占用8个字节，每条记录record占用300字节，每个页page大小为16k，那么回答下面的问题：
> 
> 如果这个B+树的高度为1，大概可以存储多少条数据？
> 
> 如果这个B+树的高度为2，大概可以存储多少条数据？
> 
> 如果这个B+树的高度为3，大概可以存储多少条数据？
> 
> 如果这个B+树的高度为4，大概可以存储多少条数据？
> 

1. 如果B+树的高度为1，说明这个树的根节点root page 就是叶子节点page。里面存储所有的数据。由于每条数据是300个字节，页面大小为16k 那么可以存储 16*1024/300 = 54条记录。
2. 如果B+树的高度为2，那么root节点页面只是存储键值和指针，那么可以存储多少个指针呢？16*1024/(8+6) = 1170个指针（其中 6 这个数字 就是一个指针占用的字节数），这么多个指针都可以指向一个page页面也就是叶子节点，一个叶子节点可以存储54条记录，那么这棵树总共可以存储大概 1170 * 54 =  63195条记录 。
3. 如果B+树的高度为3，那么除了根节点的非叶子节点可以发散出来 1170 * 1170个指针，那可以存储 1170 * 1170 * 54 = 73920600 条记录
4. 如果B+树的高度为4，则可以 1170 * 1170 * 1170 * 54 = xxx 太吓人的数字了 。
5. 综上所述，MySQL中 B+树的高度是不会太高的。

## 堆表
```
B+ TREE INDEX IN MYISAM
1. Heap Table
2. All index is non clustered / secondary
3. The difference between Primary Key and Key is not NULL and unique
4. Leaf page store data address
5. 1K per page

```
